# Ruby uses Model-View-Controller architecture with these types automatical generation

1. Create a controller
# To create a new controller

	$ cd [pathToProject]
	$ rails generate controller [controllerName]

# From now on there is a [controllerName]_controller in /[pathToProject]/app/controllers/

2. Define an action
# To define a new action within it
	def [actionName]
		[someActions]
	end

3. Create a view
# Then it is necessary to create a view in /[pathToProject]/app/views/[controllerName]/ with name=[actionName] and any content
# This content is included within <body> tag by default, or instead of <%= yield %> in layout-file. (application.html.erb by default)

4. Add a route to this view
# It is necessary to write a route to view in /[pathToProject]/config/routes.rb
# The main page is defined with
	root '[controllerName]#[actionName]'

# Any other view is added withinh a GET-request to a necessary view
	get '[controllerName]/[actionName]'

# It is possible to create an alias for any controller/action pair like this
	get '[pathInBrowser]' => '[controllerName]#[actionName]'
# From now on we have a path like http://0.0.0:3000/pathInBrowser for this controller/action pair

5. Model is a template for database records. To create a model
	$ rails g Category	#	in singular!!
# After that two important files appear in project:
	# /models/category.rb/
	# /db/migrate/create_categories

6. Migrations are manually pre-created changes in database.
# After a model was created it is necessary to run migrations, because otherwise model will link to nowhere
	$ rake db:migrate
# Migration may be rolled back
	$ rake db:rollback

7. Controller for newly created model should be generated
	$ rails g controller Categories	#	in plural!!

# Actions inside this controller will manage our model

# Ruby defines 7 names for stadard operations
	index		#	show all records
	new			#	create a record
	create		#	create a record and save it to DB
	edit		#	edit a record
	update		#	refresh a record
	show		#	show certain record
	destroy		#	delete a record

# For example, index action:
	def index
		@category	=	Category.all
		# @ means that this variable is seen inside corresponding view (index.html.erb)
		# Category.all shows all records (as with the console)
	end

# In index.html.erb (no comments)
#	<h1>Categories</h1>
#
#	<table class="table">
#		<%	@categories.each do |category|	%>
#			<tr>
#				<td><%=	category.name	%></td>
#			</tr>
#		<%	end	%>
#	</table>
#
#	<%= link_to	'Create a new category', new_category_path, class: 'btn btn-#primary'	%>

# It is possible to automatically generate all necessary routes from a controller for seven standard actions:
	#	index
	#	new
	#	create
	#	edit
	#	update
	#	destroy
	#	show
	resources :categories

	# This will automatically create all necessary paths
	#	Prefix	Verb	URI		Pattern							Controller#Action
	#			root	GET		/								welcome#index
	#			about	GET		/about(.:format)				welcome#about
	#		contacts	GET		/contacts(.:format)				about#contacts
	#			team	GET		/team(.:format)					about#team
	#		products	GET		/products(.:format)				about#products
	#		categories	GET		/categories(.:format)			categories#index
	#					POST	/categories(.:format)			categories#create
	#	new_category	GET		/categories/new(.:format)		categories#new
	#	edit_category	GET		/categories/:id/edit(.:format)	categories#edit
	#		category	GET		/categories/:id(.:format)		categories#show
	#					PATCH	/categories/:id(.:format)		categories#update
	#					PUT		/categories/:id(.:format)		categories#update
	#					DELETE	/categories/:id(.:format)		categories#destroy

