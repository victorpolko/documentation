//V 1.To define a FUNCTION
	var functionName = function (arguments)	{
		// {function body..}
	}
	//V Literally it means that I save TEXT of the anonymous function into a variable called functionName
	//V So, if right after its definition we call it (e.g. {..}() ), then this variable will only contain result of this function call, not its TEXT
	//V To save this function as a text
	var copy	=	functionName;
	//V To save the RESULT of this function call	(brackets tell it to be called! )
	var save	=	functionName(arguments);

//V 2.To define a CLASS
	function	someClass(prop1,prop2,propN)	{
		this.prop1		=	prop1;
		this.prop2		=	prop2;
		this.propN		=	propN;
		this.setProp	=	function(newProp)	{
			this.propN	=	newProp;
		};
		//V Private attribute
		var	privateAttr	=	true;
		//V It is possible to return this private paprameter by means of a public function
		this.unprivate	=	function()	{
			return privateAttr;
		};
		var functionName	=	function(args)	{
			//functionBody
		};
		function	className(args)	{
			this.args	=	args;
		}
	};
	//V From now on it is possible to create objects based upon someClass "template"
	var c	=	new someClass('AA',23,true);
	c.setProp(false);

//V 3.Check error stacktrace
	console.log((new Error()).stack)

//V	4.Instead of using multistring things like:
	var f = function(a)	{return [0, a, 2*a]};
	var t = f(1);
	var result = t[2];	// 2

	//V it is possible to use a shortcut, in this case:
	var result = function(a){return [0,a,2*a]}(1)[2];

//V 5.Construction try->catch->finally
	try {
		//V {Code to be checked for exceptions (syn. success)}
	}	catch	(error)	{
		//V {Code to be executed if there are some (syn. error)}
		throw error;	//V Throw an exception (usually to the console)
	}	finally	{
		//V {Code to be executed anyway (syn. to callback)}
		console.log('finished');
	}

//V	6.Common functions for undefined number of arguments may be got with {arguments} object
	function sum() {
	    var res = 0;
	    for (var i = 0; i < arguments.length; i++) {
	        res += arguments[i];
	    }
	    return res;
	}
	console.log(sum(3, 4));				// 7
	console.log(sum(3, 4, 5));			// 12
	console.log(sum(3, 4, 5, 7, 9));	// 28

//V	7.Recursion in functions may be got with {arguments.callee} object
	var factorial = function(step, res) {
	    res = res || 1;
	    if (step < 2) {
	        return res;
	    }
	    return arguments.callee(step - 1, step * res);
	};
	console.log(factorial(5));			// 120

//V 8.Closures are used for inner functions to have access to outer functions variables
	var uniqueId = function() {
	    var id = 0;
	    return function() { return id++; };
	}();
	var aValue = uniqueId();
	var anotherValue = uniqueId();

//V 9.Closure for only-here usage
	var getConstant = function() {
	  var constants = {											//V With this method
	    UPPER_BOUND: 100,										//V all these constants
	    LOWER_BOUND: -100										//V are no longer accessible
	  };														//V from anywhere
	  return function(constantName) {							//V except this function itself!
	    return constants[constantName];
	  };
	}();														//V Here it is called right after creation
	alert(getConstant("LOWER_BOUND")); // -100

//V 10.Currying example (many arguments->each argument)
	var multNumber = function(arg) {
	    return function(mul) {
	        return arg * mul;
	    };
	};
	var multFive = multNumber(5);
	console.log(multFive(7));			//35

//V 11.Bubbling
	//V By default, all events are worked out in order from the inner element to its highest parent.
	//V This may be omitted with the next counstruction:
	document.getElementById('uniqueId').addEventListener("click", function(event)	{
		event.stopPropagation ? event.stopPropagation() : (event.cancelBubble	=	true);	//V For cross-browser applications
	};

//V 12.Default behavior
	//V Default behavior of the browser may be omitted with this:
	document.getElementById('uniqueId').addEventListener("click", function(event)	{
		event.preventDefault ? event.preventDefault() : (event.returnValue	=	false);	//V For cross-browser applications
	};

